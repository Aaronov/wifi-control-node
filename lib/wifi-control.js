// Generated by CoffeeScript 1.9.0
(function() {
  var AirPort, Future, WiFiControlSettings, WiFiLog, WiFiScanner, connectionStateMap, execSync, execSyncToBuffer, fs, parsePatterns, powerStateMap;

  Future = require('fibers/future');

  WiFiScanner = require('node-wifiscanner2');

  fs = require('fs');

  execSyncToBuffer = require('execSync').exec;

  WiFiControlSettings = {
    iface: null,
    debug: false
  };

  parsePatterns = {};

  connectionStateMap = {
    init: "disconnected",
    running: "connected"
  };

  powerStateMap = {
    On: true,
    Off: false,
    enabled: true,
    disabled: false
  };

  switch (process.platform) {
    case "linux":
      parsePatterns.nmcli_line = new RegExp(/([^:]+):\s+(.*)+/);
      break;
    case "win32":
      parsePatterns.netsh_line = new RegExp(/([^:]+): (.*)+/);
      break;
    case "darwin":
      AirPort = "/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport";
      parsePatterns.airport_line = new RegExp(/(.*)+: (.*)+/);
  }

  execSync = function(command, options) {
    var results;
    if (options == null) {
      options = {};
    }
    results = execSyncToBuffer(command, options);
    if (!results.code) {
      return results.stdout;
    }
    throw {
      stderr: results.stdout
    };
  };

  WiFiLog = function(msg, error) {
    if (error == null) {
      error = false;
    }
    if (error) {
      return console.error("WiFiControl: " + msg);
    } else {
      if (WiFiControlSettings.debug) {
        return console.log("WiFiControl: " + msg);
      }
    }
  };

  module.exports = {
    init: function(settings) {
      if (settings == null) {
        settings = {};
      }
      this.configure(settings);
      if (settings.iface == null) {
        return this.findInterface(settings.iface);
      }
    },
    configure: function(settings) {
      if (settings == null) {
        settings = {};
      }
      if (settings.debug != null) {
        WiFiControlSettings.debug = settings.debug;
        WiFiLog("Debug mode set to: " + settings.debug);
      }
      if (settings.iface != null) {
        return this.findInterface(settings.iface);
      }
    },
    findInterface: function(iface) {
      var error, findInterfaceCom, interfaceResults, parsedLine, _iface, _interface, _interfaceLine, _msg;
      if (iface == null) {
        iface = null;
      }
      try {
        if (iface != null) {
          _msg = "Wireless interface manually set to " + iface + ".";
          WiFiLog(_msg);
          WiFiControlSettings.iface = iface;
          return {
            success: true,
            msg: _msg,
            "interface": iface
          };
        }
        WiFiLog("Determining system wireless interface...");
        switch (process.platform) {
          case "linux":
            WiFiLog("Host machine is Linux.");
            findInterfaceCom = "nmcli -m multiline device status | grep wlan";
            WiFiLog("Executing: " + findInterfaceCom);
            _interfaceLine = execSync(findInterfaceCom);
            parsedLine = parsePatterns.nmcli_line.exec(_interfaceLine.trim());
            _interface = parsedLine[2];
            if (_interface) {
              _iface = _interface.trim();
              _msg = "Automatically located wireless interface " + _iface + ".";
              WiFiLog(_msg);
              interfaceResults = {
                success: true,
                msg: _msg,
                "interface": _iface
              };
            } else {
              _msg = "Error: No network interface found.";
              WiFiLog(_msg, true);
              interfaceResults = {
                success: false,
                msg: _msg,
                "interface": null
              };
            }
            break;
          case "win32":
            WiFiLog("Host machine is Windows.");
            findInterfaceCom = "echo wlan";
            WiFiLog("Executing: " + findInterfaceCom);
            _interface = execSync(findInterfaceCom);
            if (_interface) {
              _iface = _interface.trim();
              _msg = "Automatically located wireless interface " + _iface + ".";
              WiFiLog(_msg);
              interfaceResults = {
                success: true,
                msg: _msg,
                "interface": _iface
              };
            } else {
              _msg = "Error: No network interface found.";
              WiFiLog(_msg, true);
              interfaceResults = {
                success: false,
                msg: _msg,
                "interface": null
              };
            }
            break;
          case "darwin":
            WiFiLog("Host machine is MacOS.");
            findInterfaceCom = "networksetup -listallhardwareports | awk '/^Hardware Port: (Wi-Fi|AirPort)$/{getline;print $2}'";
            WiFiLog("Executing: " + findInterfaceCom);
            _interface = execSync(findInterfaceCom);
            if (_interface) {
              _iface = _interface.trim();
              _msg = "Automatically located wireless interface " + _iface + ".";
              WiFiLog(_msg);
              interfaceResults = {
                success: true,
                msg: _msg,
                "interface": _iface
              };
            } else {
              _msg = "Error: No network interface found.";
              WiFiLog(_msg, true);
              interfaceResults = {
                success: false,
                msg: _msg,
                "interface": null
              };
            }
            break;
          default:
            WiFiLog("Unrecognized operating system.  No known method for acquiring wireless interface.");
            interfaceResults = {
              success: false,
              msg: "No valid wireless interface could be located.",
              "interface": null
            };
        }
        WiFiControlSettings.iface = interfaceResults["interface"];
        return interfaceResults;
      } catch (_error) {
        error = _error;
        _msg = "Encountered an error while searching for wireless interface: " + error;
        WiFiLog(_msg, true);
        return {
          success: false,
          msg: _msg
        };
      }
    },
    scanForWiFi: function() {
      var KEY, VALUE, c, error, k, ln, networks, nwk, parsedLine, scanRequest, scanResults, _i, _j, _len, _len1, _msg, _network, _ref, _ref1;
      if (WiFiControlSettings.iface == null) {
        _msg = "You cannot scan for nearby WiFi networks without a valid wireless interface.";
        WiFiLog(_msg, true);
        return {
          success: false,
          msg: _msg
        };
      }
      try {
        WiFiLog("Scanning for nearby WiFi Access Points...");
        if (process.platform === "linux") {
          scanResults = execSync("nmcli -m multiline device wifi list");
          networks = [];
          _ref = scanResults.split('*:');
          for (c = _i = 0, _len = _ref.length; _i < _len; c = ++_i) {
            nwk = _ref[c];
            if (c === 0) {
              continue;
            }
            _network = {};
            _ref1 = nwk.split('\n');
            for (k = _j = 0, _len1 = _ref1.length; _j < _len1; k = ++_j) {
              ln = _ref1[k];
              try {
                parsedLine = parsePatterns.nmcli_line.exec(ln.trim());
                KEY = parsedLine[1];
                VALUE = parsedLine[2];
              } catch (_error) {
                error = _error;
                continue;
              }
              switch (KEY) {
                case "SSID":
                  _network.ssid = String(VALUE);
                  break;
                case "CHAN":
                  _network.channel = String(VALUE);
                  break;
                case "SIGNAL":
                  _network.signal_level = String(VALUE);
                  break;
                case "SECURITY":
                  _network.security = String(VALUE);
              }
            }
            if (_network.ssid !== "--") {
              networks.push(_network);
            }
          }
          _msg = "Nearby WiFi APs successfully scanned (" + networks.length + " found).";
          WiFiLog(_msg);
          return {
            success: true,
            msg: _msg,
            networks: networks
          };
        } else {
          scanRequest = new Future;
          WiFiScanner.scan((function(_this) {
            return function(error, data) {
              if (error) {
                WiFiLog("Error: " + error, true);
                return scanRequest["return"]({
                  success: false,
                  msg: "We encountered an error while scanning for WiFi APs: " + error
                });
              } else {
                _msg = "Nearby WiFi APs successfully scanned (" + data.length + " found).";
                WiFiLog(_msg);
                return scanRequest["return"]({
                  success: true,
                  networks: data,
                  msg: _msg
                });
              }
            };
          })(this));
          return scanRequest.wait();
        }
      } catch (_error) {
        error = _error;
        return {
          success: false,
          msg: "We encountered an error while scanning for WiFi APs: " + error
        };
      }
    },
    connectToAP: function(_ap) {
      var COMMANDS, com, connectToAPChain, error, i, ifaceState, ssidExist, ssid_hex, stdout, xmlContent, xmlWriteRequest, _i, _j, _len, _msg, _ref;
      if (WiFiControlSettings.iface == null) {
        _msg = "You cannot connect to a WiFi network without a valid wireless interface.";
        WiFiLog(_msg, true);
        return {
          success: false,
          msg: _msg
        };
      }
      try {
        if (!_ap.ssid.length) {
          return {
            success: false,
            msg: "Please provide a non-empty SSID."
          };
        }
        if (_ap.password == null) {
          _ap.password = "";
        }
        switch (process.platform) {
          case "linux":
            COMMANDS = {
              "delete": "nmcli connection delete \"" + _ap.ssid + "\"",
              connect: "nmcli device wifi connect \"" + _ap.ssid + "\""
            };
            if (_ap.password.length) {
              COMMANDS.connect += " password \"" + _ap.password + "\"";
            }
            try {
              stdout = execSync("nmcli connection show \"" + _ap.ssid + "\"");
              if (stdout.length) {
                ssidExist = true;
              }
            } catch (_error) {
              error = _error;
              ssidExist = false;
            }
            connectToAPChain = [];
            if (ssidExist) {
              WiFiLog("It appears there is already a connection for this SSID.");
              connectToAPChain.push("delete");
            }
            connectToAPChain.push("connect");
            break;
          case "win32":
            WiFiLog("Generating win32 wireless profile...");
            ssid_hex = "";
            for (i = _i = 0, _ref = _ap.ssid.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
              ssid_hex += ssid.charCodeAt(i).toString(16);
            }
            xmlContent = "<?xml version=\"1.0\"?> <WLANProfile xmlns=\"http://www.microsoft.com/networking/WLAN/profile/v1\"> <name>" + _ap.ssid + "</name> <SSIDConfig> <SSID> <hex>" + ssid_hex + "</hex> <name>" + _ap.ssid + "</name> </SSID> </SSIDConfig> <connectionType>ESS</connectionType> <connectionMode>manual</connectionMode> <MSM> <security> <authEncryption> <authentication>open</authentication> <encryption>none</encryption> <useOneX>false</useOneX> </authEncryption> </security> </MSM> </WLANProfile>";
            xmlWriteRequest = new Future;
            fs.writeFile(_ap.ssid + ".xml", xmlContent, function(err) {
              if (err != null) {
                WiFiLog(err, true);
                return xmlWriteRequest["return"](false);
              } else {
                return xmlWriteRequest["return"](true);
              }
            });
            if (!xmlWriteRequest.wait()) {
              return {
                success: false,
                msg: "Encountered an error connecting to AP:"
              };
            }
            COMMANDS = {
              loadProfile: "netsh " + WiFiControlSettings.iface + " add profile filename=\"" + _ap.ssid + ".xml\"",
              connect: "netsh " + WiFiControlSettings.iface + " connect ssid=\"" + _ap.ssid + "\" name=\"" + _ap.ssid + "\""
            };
            connectToAPChain = ["loadProfile", "connect"];
            break;
          case "darwin":
            COMMANDS = {
              connect: "networksetup -setairportnetwork " + WiFiControlSettings.iface + " \"" + _ap.ssid + "\""
            };
            if (_ap.password.length) {
              COMMANDS.connect += " \"" + _ap.password + "\"";
            }
            connectToAPChain = ["connect"];
        }
        for (_j = 0, _len = connectToAPChain.length; _j < _len; _j++) {
          com = connectToAPChain[_j];
          WiFiLog("Executing:\t" + COMMANDS[com]);
          try {
            stdout = execSync(COMMANDS[com]);
          } catch (_error) {
            error = _error;
            if (process.platform === "linux") {
              if (error.stderr.toString().trim() === ("Error: No network with SSID '" + _ap.ssid + "' found.")) {
                _msg = "Error: No network called " + _ap.ssid + " could be found.";
                WiFiLog(_msg, true);
                return {
                  success: false,
                  msg: _msg
                };
              }
              if (!/nmcli device wifi connect/.test(COMMANDS[com])) {
                WiFiLog(error, true);
                return {
                  success: false,
                  msg: error
                };
              }
            }
          }
          switch (process.platform) {
            case "darwin":
              if (stdout === ("Could not find network " + _ap.ssid + ".")) {
                _msg = "Error: No network called " + _ap.ssid + " could be found.";
                WiFiLog(_msg, true);
                return {
                  success: false,
                  msg: _msg
                };
              }
          }
          WiFiLog("Success!");
        }
        WiFiLog("Waiting for connection attempt to settle...");
        while (true) {
          ifaceState = this.getIfaceState();
          if (ifaceState.success) {
            if (ifaceState.state === "connected") {
              break;
            } else if (ifaceState.state === "disconnected") {
              _msg = "Error: Interface is not currently connected to any wireless AP.";
              WiFiLog(_msg, true);
              return {
                success: false,
                msg: _msg
              };
            }
          }
        }
        if (ifaceState.ssid === _ap.ssid) {
          _msg = "Successfully connected to " + _ap.ssid + "!";
          WiFiLog(_msg);
          return {
            success: true,
            msg: _msg
          };
        } else {
          _msg = "Error: Interface is currently connected to " + ifaceState.ssid;
          WiFiLog(_msg, true);
          return {
            success: false,
            msg: _msg
          };
        }
      } catch (_error) {
        error = _error;
        _msg = "Encountered an error while connecting to " + _ap.ssid + ": " + error;
        WiFiLog(_msg, true);
        return {
          success: false,
          msg: _msg
        };
      }
    },
    resetWiFi: function() {
      var COMMANDS, com, error, ifaceState, resetWiFiChain, stdout, _i, _len, _msg;
      try {
        switch (process.platform) {
          case "linux":
            COMMANDS = {
              disableNetworking: "nmcli networking off",
              enableNetworking: "nmcli networking on"
            };
            resetWiFiChain = ["disableNetworking", "enableNetworking"];
            break;
          case "win32":
            COMMANDS = {
              disconnect: "netsh " + WiFiControlSettings.iface + " disconnect"
            };
            resetWiFiChain = ["disconnect"];
            break;
          case "darwin":
            COMMANDS = {
              enableAirport: "networksetup -setairportpower " + WiFiControlSettings.iface + " on",
              disableAirport: "networksetup -setairportpower " + WiFiControlSettings.iface + " off"
            };
            resetWiFiChain = ["disableAirport", "enableAirport"];
        }
        for (_i = 0, _len = resetWiFiChain.length; _i < _len; _i++) {
          com = resetWiFiChain[_i];
          WiFiLog("Executing:\t" + COMMANDS[com]);
          stdout = execSync(COMMANDS[com]);
          _msg = "Success!";
          WiFiLog(_msg);
        }
        WiFiLog("Waiting for interface to finish resetting...");
        while (true) {
          ifaceState = this.getIfaceState();
          if (ifaceState.success) {
            if (ifaceState.power) {
              break;
            }
          } else {
            _msg = "Error: Interface could not be reset.";
            WiFiLog(_msg, true);
            return {
              success: false,
              msg: _msg
            };
          }
        }
        return {
          success: true,
          msg: "Successfully reset WiFi!"
        };
      } catch (_error) {
        error = _error;
        _msg = "Encountered an error while resetting wireless interface: " + error;
        WiFiLog(_msg, true);
        return {
          success: false,
          msg: _msg
        };
      }
    },
    getIfaceState: function() {
      var KEY, VALUE, connectionData, connectionName, error, foundInterface, interfaceState, k, ln, parsedLine, powerData, ssidData, _i, _j, _k, _len, _len1, _len2, _msg, _ref, _ref1, _ref2;
      try {
        interfaceState = {};
        switch (process.platform) {
          case "linux":
            powerData = execSync("nmcli networking");
            interfaceState.power = powerStateMap[powerData.trim()];
            if (interfaceState.power) {
              foundInterface = false;
              connectionData = execSync("nmcli -m multiline device status");
              connectionName = null;
              _ref = connectionData.split('\n');
              for (k = _i = 0, _len = _ref.length; _i < _len; k = ++_i) {
                ln = _ref[k];
                try {
                  parsedLine = parsePatterns.nmcli_line.exec(ln.trim());
                  KEY = parsedLine[1];
                  VALUE = parsedLine[2];
                  if (VALUE === "--") {
                    VALUE = null;
                  }
                } catch (_error) {
                  error = _error;
                  continue;
                }
                switch (KEY) {
                  case "DEVICE":
                    if (VALUE === WiFiControlSettings.iface) {
                      foundInterface = true;
                    }
                    break;
                  case "STATE":
                    if (foundInterface) {
                      interfaceState.state = VALUE;
                    }
                    break;
                  case "CONNECTION":
                    if (foundInterface) {
                      connectionName = VALUE;
                    }
                }
                if (KEY === "CONNECTION" && foundInterface) {
                  break;
                }
              }
              if (!foundInterface) {
                return {
                  success: false,
                  msg: "Unable to retrieve state of network interface " + WiFiControlSettings.iface + "."
                };
              }
              if (connectionName) {
                try {
                  ssidData = execSync("nmcli -m multiline connection show \"" + connectionName + "\" | grep 802-11-wireless.ssid");
                  parsedLine = parsePatterns.nmcli_line.exec(ssidData.trim());
                  interfaceState.ssid = parsedLine[2];
                } catch (_error) {
                  error = _error;
                  return {
                    success: false,
                    msg: "Error while retrieving SSID information of network interface " + WiFiControlSettings.iface + ": " + error.stderr
                  };
                }
              } else {
                interfaceState.ssid = null;
              }
            } else {
              interfaceState.state = "disconnected";
              interfaceState.ssid = null;
            }
            break;
          case "win32":
            connectionData = execSync("netsh " + WiFiControlSettings.iface + " show interface");
            _ref1 = connectionData.split('\n');
            for (k = _j = 0, _len1 = _ref1.length; _j < _len1; k = ++_j) {
              ln = _ref1[k];
              try {
                parsedLine = parsePatterns.netsh_line.exec(ln.trim());
                KEY = parsedLine[1].trim();
                VALUE = parsedLine[2].trim();
              } catch (_error) {
                error = _error;
                continue;
              }
              switch (KEY) {
                case "State":
                  interfaceState.state = connectionStateMap[VALUE];
                  break;
                case "SSID":
                  interfaceState.ssid = VALUE;
              }
              if (KEY === "SSID") {
                break;
              }
            }
            break;
          case "darwin":
            connectionData = execSync(AirPort + " -I");
            _ref2 = connectionData.split('\n');
            for (k = _k = 0, _len2 = _ref2.length; _k < _len2; k = ++_k) {
              ln = _ref2[k];
              try {
                parsedLine = parsePatterns.airport_line.exec(ln.trim());
                KEY = parsedLine[1];
                VALUE = parsedLine[2];
              } catch (_error) {
                error = _error;
                continue;
              }
              switch (KEY) {
                case "state":
                  interfaceState.state = connectionStateMap[VALUE];
                  break;
                case "SSID":
                  interfaceState.ssid = VALUE;
              }
              if (KEY === "SSID") {
                break;
              }
            }
            powerData = execSync("networksetup -getairportpower " + WiFiControlSettings.iface);
            try {
              parsedLine = parsePatterns.airport_line.exec(powerData.trim());
              KEY = parsedLine[1];
              VALUE = parsedLine[2];
            } catch (_error) {
              error = _error;
              return {
                success: false,
                msg: "Unable to retrieve state of network interface " + WiFiControlSettings.iface + "."
              };
            }
            interfaceState.power = powerStateMap[VALUE];
        }
        return {
          success: true,
          msg: "Successfully acquired state of network interface " + WiFiControlSettings.iface + ".",
          ssid: interfaceState.ssid,
          state: interfaceState.state,
          power: interfaceState.power
        };
      } catch (_error) {
        error = _error;
        _msg = "Encountered an error while acquiring network interface connection state: " + error;
        WiFiLog(_msg, true);
        return {
          success: false,
          msg: _msg
        };
      }
    }
  };

}).call(this);
